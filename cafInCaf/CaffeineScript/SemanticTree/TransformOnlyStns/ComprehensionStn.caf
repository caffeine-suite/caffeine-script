import &StandardImport

class ComprehensionStn extends &ScopeStnMixin &BaseStn

  ###
    TODO explicit iterationTypes:
      ExampleA: object v from-array a
      ExampleB: object v from-object a
      ExampleC: object v from-iter a

      UPDATE 2018-5-4:
        Currently, chrome is full-speed with closureless functions,
        but if there is a closure, even if there is no escape, there is a 7x
        speed penaltiy: https://jsbench.me/1nj5v4npva

        Safari is much worse - it's a 30x difference between using
        an existing function vs a newly created one, no matter
        the structure of the funciton.

        FireFox: no-closure is fast, but w-closure is 60x slower!

        However, all three ARE full-speed with an external function vs
        inlining.

        All of which means, elliminating function creation is still a big
        win.

      My plan is to actually make inline loops for explicit from-type iteration.


  validate: ->
    {valueClauses, variableDefinition} = @labeledChildren
    if variableDefinition?.children.length > 2
      throw new Error "Can define at most two loop variables (value followed optionally by key). You defined: #{variableDefinition.parseTreeNode?.toString()}."

    {comprehensionType} = @

    {toClause, byClause, tilClause, fromClause, fromArrayClause} = @labeledClauses

    if (toClause || byClause || tilClause || fromArrayClause) && comprehensionType != :array
      throw new Error "" 'from-array', 'to', 'by' and 'til' clauses not supported for '#{comprehensionType}' comprehensions (clauses found: #{(array clause in @labeledClauses when clause with clause.clauseType).join ', '})

    unless fromClause || toClause || tilClause || fromArrayClause
      throw new Error "" 'from', 'from-array', 'to' or 'til' clause require (clauses found: #{(array clause in @labeledClauses when clause with clause.clauseType).join ', '})

    if toClause && tilClause
      throw new Error "" only one 'to' or 'til' clause allowed (clauses found: #{(array clause in @labeledClauses when clause with clause.clauseType).join ', '})

    if byClause && !(tilClause || toClause)
      throw new Error "" 'to' or 'til' clause required to use 'by' (clauses found: #{(array clause in @labeledClauses when clause with clause.clauseType).join ', '})

  clauseAliases =
    returning:  :into
    in:         :from
    do:         :with

  @getter
    comprehensionType: -> @labeledChildren.outputType.props.token

    labeledClauses: ->
      {iterable, body} = @labeledChildren
      labeledClauses = {}

      each {type, value} in @labeledChildren.valueClauses
        type = clauseAliases[type] ? type
        name = lowerCamelCase type + :Clause
        if labeledClauses[name]
          throw new Error "" no more than one '#{type}' clause allowed
        value.clauseType = type
        labeledClauses[name] = value

      labeledClauses.fromClause ?= iterable
      labeledClauses.withClause ?= body

      labeledClauses

  postTransform: ->
    @initLabeledChildren()

    {labeledClauses, comprehensionType} = @

    if labeledClauses.fromArrayClause
      @generateFromArray labeledClauses
    else if labeledClauses.toClause || labeledClauses.tilClause
      @generateArrayRange labeledClauses
    else
      switch comprehensionType
      when :each, :array, :object
        @generateArrayOrEach
          if comprehensionType == :each then :each2 else comprehensionType
          labeledClauses

      when :find
        @generateFind
          labeledClauses

  resolveStnParams: (params...) ->
    {variableDefinition} = @labeledChildren

    lastNonNulIndex = 0
    params = array p, i in params
      p = switch
      when p is Object
        {f} = p
        if f
          FunctionDefinitionStn
            bound: true
            variableDefinition
            f
      when p is String
        SimpleLiteralStn value: p

      else p

      lastNonNulIndex = i if p?
      p

    Null = null
    params = params.slice 0, lastNonNulIndex + 1
    array p in params
      p ? Null ?= SimpleLiteralStn value: :null

  # Caf.arrayRange(fromValue, toValue, withClause = returnFirst, whenClause = returnTrue, byValue, til, into = []) ->
  generateArrayRange: ({withClause, whenClause, toClause, tilClause, byClause, fromClause, intoClause})->

    if tilClause
      toClause = tilClause
      tilClause = :true

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.arrayRange

      @resolveStnParams
        fromClause ? "0"
        toClause
        {} f: withClause
        {} f: whenClause
        byClause
        tilClause
        intoClause

  generateFromArray: ({fromArrayClause, intoClause, withClause, whenClause})->
    {variableDefinition} = @labeledChildren
    variableDefinition = variableDefinition?.children
    fromId      = IdentifierStn preferredIdentifier: :from
    intoId      = IdentifierStn preferredIdentifier: :into
    iId         = IdentifierStn preferredIdentifier: :i
    lengthId    = IdentifierStn preferredIdentifier: :length

    unless variableDefinition
      variableDefinition = [] IdentifierStn preferredIdentifier: :v

    [valueId] = variableDefinition

    # log {variableDefinition}

    invokeWithClauseAndPush =
      FunctionInvocationStn
        AccessorStn intoId, IdentifierStn "push"
        withClause ? valueId

    StatementsStn
      AssignmentStn fromId, BinaryOperatorStn
        operator: "||"
        fromArrayClause
        PureJsStn "[]"

      AssignmentStn lengthId, AccessorStn fromId, IdentifierStn "length"
      AssignmentStn iId, PureJsStn "0"
      AssignmentStn intoId, intoClause ? PureJsStn "" []

      WhileStn
        BinaryOperatorStn
          operator: "<"
          iId
          lengthId
        StatementsStn
          LetStn
            array v, i in variableDefinition
              AssignmentStn
                v
                if i == 0 then AccessorStn fromId, iId
                else iId
          if whenClause
            IfStn whenClause, invokeWithClauseAndPush
          else
            invokeWithClauseAndPush

          UnaryOperatorStn
            operand: :++
            tail: true
            iId
      intoId

    # if whenClause
    #   while _i < length
    #     let v = fromArray[i]
    #     let k = _i
    #     if whenClause v, k
    #       intoArray.push withClause v, k
    #     i++

    # else
    #   while _i < length
    #     let v = fromArray[i]
    #     let k = _i
    #     intoArray.push withClause v, k
    #     i++

    # intoArray


  # Caf.find(source, withClause, whenClause) ->
  generateFind: ({fromClause, withClause, whenClause})->
    {iterable, variableDefinition} = @labeledChildren

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.find

      @resolveStnParams
        fromClause
        {} f: withClause
        {} f: whenClause

  # Caf.array( source, withClause = returnFirst, whenClause = returnTrue, into = []) ->
  # Caf.object(source, withClause = returnFirst, whenClause = returnTrue, into = {}) ->
  # Caf.each2( source, withClause = returnFirst, whenClause = returnTrue, into)
  generateArrayOrEach: (method, {fromClause, intoClause, withClause, whenClause, withKeyClause})->
    {variableDefinition} = @labeledChildren

    # if the value-variable is defined, it's a destructuring set the special default withClause
    # Example: array {a}        # default: with {a}
    # Example: array extract a  # default: with a     - extract not impleneted as-of this writing
    if variableDefinition?.children?.length > 0 && !variableDefinition.children[0].isSimpleIdentifier
      withClause ?= StatementsStn variableDefinition.children[0]

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.#{method}

      @resolveStnParams
        fromClause
        {} f: withClause
        {} f: whenClause
        intoClause
        {} f: withKeyClause
