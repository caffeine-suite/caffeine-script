import &StandardImport
StnRegistry = &StnRegistry

##
  Thinking.

  I want a FunctionDefinitionStn which is scopeless.
  - It doesn't act like a scope for variables which are only assigned within it.
    - Those variables are letted in the enclosing scope.
  - If it has args, it calls @scope.addIdentifierAssigned for each using the parent scope.
  - The generated javascript uses temp variables for each of the args and then at the start
    of the function, it assigns those args to the actual-named variables bound in the enclosing
    scope.

  WHY? There are 2 or more places where I am adding new control-structures which don't define scope
  but are implemented with function-defs in javascript:
    - iterators (each, array, object, etc...)
    - promises
    - do block (?)

class FunctionDefinitionStn extends &ScopeStnMixin &BaseStn

  ###
    IN:
      props:
        bound: if true, use () => {} form, else function() {}
        returnIgnored: if true, no return statement is generated
        isConstructor: if true
          - ensure there is a super and put it in the right order
          - returnIgnored: true is implicit

  constructor: (props, children, pretransformedStn) ->
    if children.length == 1
      [onlyChild] = children
      unless onlyChild instanceof StnRegistry.FunctionDefinitionArgsStn.class
        children = [StnRegistry.FunctionDefinitionArgsStn(), children[0]]
    super props, children, pretransformedStn

    @arguments = children[0]
    @statements = children[1]
    @_updatingArgumentScope = false

  cloneWithNewStatements: (statements)->
    new @class @props, [@arguments, StnRegistry.StatementsStn compactFlatten statements]

  @getter
    needsParens: -> false
    needsParensAsStatement: -> !@props.bound

    childrenToUpdateScope: -> compactFlatten [@statements]

  updateScope: ->
    super
    if @arguments
      object name from @arguments.argumentNameList with @addArgumentName name
      @_updatingArgumentScope = true
      @arguments.updateScope @
      @_updatingArgumentScope = false

  addIdentifierAssigned: (identifier) ->
    if @_updatingArgumentScope
      @addArgumentName identifier
    else
      super

  postTransform: ->
    if @props.bound == "auto"
      @props.bound = if foundParent = @pretransformedStn.findParent /Class|FunctionDefinition/
        if foundParent.type == "Class"
          false
        else
          true
      else
        false

    super

  ##
    NOTES:

    toSourceNode: (options) ->

    Handling super in constructors is the trick. It may not be too hard.

    We have to scan the body-statements and determine the first one
    that contains a "super" call.

      Specifically, we recurse down the Semantic tree, looking for
      super, but not recursing into function or class definitions.

    ON! And, super-insertion should be a transform; It shouldn't
    even be in toJs / toSourceNode.

    What about preBodyStatements?

    Ultimately, they probably should also be part of the transform.

    But we can do this refactor incrementally. except... prebody statements must come after
    super...


  getBodyJs: ->
    {returnIgnored, isConstructor} = @props
    returnIgnored ||= isConstructor

    [argsDef, body] = @children

    preBodyStatements = array arg in argsDef?.children
      arg.getFunctionPreBodyStatementsJs()

    bodyJsArray = body?.toFunctionBodyJsArray !returnIgnored

    statements = compactFlatten if isConstructor
      constructorSuperIndex = find v, i in bodyJsArray when v.match /^super\(/ with i

      if constructorSuperIndex? && constructorSuperIndex >= 0
        beforeSuper = bodyJsArray.slice 0, constructorSuperIndex
        afterSuper = bodyJsArray.slice constructorSuperIndex + 1, bodyJsArray.length
        superJs = bodyJsArray[constructorSuperIndex]
        [@getAutoLets(), beforeSuper, superJs, preBodyStatements, afterSuper]

      else
        [@getAutoLets(), "super(...arguments)", preBodyStatements, bodyJsArray]

    else
      [@getAutoLets(), preBodyStatements, bodyJsArray]

    if statements.length > 0
      "#{statements.join '; '};"
    else ""

  getArgsJs: ->
    @children[0]?.toJs() ? "()"

  toJs: ->
    {isConstructor, bound} = @props

    if bound
      "#{@getArgsJs()} => {#{@getBodyJs()}}"
    else
      "#{if isConstructor then "constructor" else "function"}#{@getArgsJs()} {#{@getBodyJs()}}"
