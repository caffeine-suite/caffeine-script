import &StandardImport

SemanticTree = &StnRegistry
UniqueIdentifierHandle = &UniqueIdentifierHandle

class ComprehensionStn extends &ScopeStnMixin &BaseStn

  ###
    TODO
    capture-loop-variables (CLV):
      Some circumstances require capturing the loop variables:

      - when-block assigns to any of the loop variables
        (and the with-block reads the one or more of those assigned variables)
        (or there is no with-block and the when-block assigns to the value-loop-variable)
        Basically, I think the first pass is: when-block-assigns-to-any-loop-variable.

      - there is already a same-named variable in the enclosing scope as one of the loop variables

      If we detect we should capture-loop-variables, we need to:

      - declare that we assign to the loop variables. This will create the correct lets, taking into
        account if any of the loop variables matches an enclosing-scope-variable.

      - capture all loop variables in the when-block, if present, otherwise in the with-block.
        If the when-block is present, then the with-block's arguments become empty - it just uses
        the captured values.

        - generate an unused variable name for each loop variable, perferrably similar to each, then:
        - (_value, _key, _into, _whenResult) => {value = _value; key = _key; into = _into; whenResult = _whenResult}
        - but only for the loop-variables declared.

      - Explicitly create the default with-block if only the when-block is present so that it can
        use the captured value-variable rather than the one passed to it by the iteration function.
        This covers the special case of the when-block assigning to the value-variable.

    TODO explicit iterationTypes:
      ExampleA: object v from-array a
      ExampleB: object v from-object a
      ExampleC: object v from-iter a

      I really need to test if that has any practical performance gain.

      UPDATE 2018-5-4:
        Currently, chrome is full-speed with closureless functions,
        but if there is a closure, even if there is no escape, there is a 7x
        speed penaltiy: https://jsbench.me/1nj5v4npva

        Safari is much worse - it's a 30x difference between using
        an existing function vs a newly created one, no matter
        the structure of the funciton.

        FireFox: no-closure is fast, but w-closure is 60x slower!

        However, all three ARE full-speed with an external function vs
        inlining.

        All of which means, elliminating function creation is still a big
        win.

      It would dramatically increase the size of the iteration library
      to take into account all those sub-options.

      Not sure it's worth it.

      My intention is to provide the standard javascript 'while' loop for performance - and
      for the ability to use returns and breaks. The only change is while returns a value,
        probably the value returned from the last execution of the body or undefined.

      If we do explicit iterationTypes, my intention is the lib names be:

      oFromA
      oFromO
      oFromI

      and so on for o, a, f, r, e >> 3x the functions

  validate: ->
    {valueClauses, variableDefinition} = @labeledChildren
    if variableDefinition?.children.length > 2
      throw new Error "Can define at most two loop variables (value followed optionally by key). You defined: #{variableDefinition.parseTreeNode?.toString()}."

    {comprehensionType} = @

    {toClause, byClause, tilClause, fromClause} = @labeledClauses

    if (toClause || byClause || tilClause) && comprehensionType != :array
      throw new Error "" 'to', 'by' and 'til' clauses not supported for '#{comprehensionType}' comprehensions

    unless fromClause || toClause || tilClause
      throw new Error "" 'from', 'to' or 'til' clause require

    if toClause && tilClause
      throw new Error "" only one 'to' or 'til' clause allowed

    if byClause && !(tilClause || toClause)
      throw new Error "" 'to' or 'til' clause required to use 'by'

  clauseAliases =
    returning:  :into
    in:         :from
    do:         :with

  @getter
    comprehensionType: -> @labeledChildren.outputType.props.token

    labeledClauses: ->
      {iterable, body} = @labeledChildren
      labeledClauses = {}

      each {type, value} in @labeledChildren.valueClauses
        type = clauseAliases[type] ? type
        name = lowerCamelCase type + :Clause
        if labeledClauses[name]
          throw new Error "" no more than one '#{type}' clause allowed
        labeledClauses[name] = value

      labeledClauses.fromClause ?= iterable
      labeledClauses.withClause ?= body

      labeledClauses

  postTransform: ->
    @initLabeledChildren()
    {outputType} = @labeledChildren

    {labeledClauses} = @

    if labeledClauses.toClause || labeledClauses.tilClause
      @generateArrayRange labeledClauses
    else
      switch outputType = @comprehensionType
      when :each, :array, :object
        @generateArrayOrEach
          if outputType == :each then :each2 else outputType
          labeledClauses

      when :find
        @generateFind
          labeledClauses

  resolveStnParams: (params...) ->
    {SimpleLiteralStn, FunctionDefinitionStn} = StnRegistry
    {variableDefinition} = @labeledChildren

    lastNonNulIndex = 0
    params = array p, i in params
      p = switch
      when p is Object
        {f} = p
        if f
          FunctionDefinitionStn
            bound: true
            variableDefinition
            f
      when p is String
        SimpleLiteralStn value: p

      else p

      lastNonNulIndex = i if p?
      p

    Null = null
    params = params.slice 0, lastNonNulIndex + 1
    array p in params
      p ? Null ?= SimpleLiteralStn value: :null

  generateArrayRange: ({withClause, whenClause, toClause, tilClause, byClause, fromClause, intoClause})->
    {FunctionInvocationStn, IdentifierStn, FunctionDefinitionStn, SimpleLiteralStn} = StnRegistry

    if tilClause
      toClause = tilClause
      tilClause = :true

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.arrayRange

      @resolveStnParams
        fromClause ? "0"
        toClause
        {} f: withClause
        {} f: whenClause
        byClause
        tilClause
        intoClause

  generateFind: ({fromClause, withClause, whenClause})->
    {iterable, variableDefinition} = @labeledChildren
    {FunctionInvocationStn, IdentifierStn, FunctionDefinitionStn, SimpleLiteralStn} = StnRegistry

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.find

      fromClause

      if withClause
        FunctionDefinitionStn
          bound: true
          variableDefinition
          withClause

      else if whenClause
        SimpleLiteralStn value: :null

      if whenClause
        FunctionDefinitionStn
          bound: true
          variableDefinition
          whenClause

  # Caf.array( source, withClause = returnFirst, whenClause = returnTrue, into = []) ->
  # Caf.object(source, withClause = returnFirst, whenClause = returnTrue, into = {}) ->
  # Caf.each2( source, withClause = returnFirst, whenClause = returnTrue, into)
  generateArrayOrEach: (method, {fromClause, intoClause, withClause, whenClause, withKeyClause})->
    {FunctionInvocationStn, StatementsStn, IdentifierStn, SimpleLiteralStn, FunctionDefinitionStn} = StnRegistry
    {variableDefinition} = @labeledChildren

    if variableDefinition?.children?.length > 0 && !variableDefinition.children[0].isSimpleIdentifier
      withClause ?= StatementsStn variableDefinition.children[0]

    Null = SimpleLiteralStn value: :null

    FunctionInvocationStn
      IdentifierStn identifier: "" Caf.#{method}

      fromClause

      if withClause
        FunctionDefinitionStn
          bound: true
          variableDefinition
          withClause
      else if whenClause || withKeyClause || intoClause
        Null

      if whenClause
        FunctionDefinitionStn
          bound: true
          variableDefinition
          whenClause
      else if withKeyClause || intoClause
        Null

      intoClause ? if withKeyClause then Null

      if withKeyClause
        FunctionDefinitionStn
          bound: true
          variableDefinition
          withKeyClause

