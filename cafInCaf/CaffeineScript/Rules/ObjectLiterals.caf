import &StandardImport, &CaffeineEight, &StnRegistry
import Extensions

->
  @rule
    object:
      :implicitObject
      :explicitObject

    objectLiteralBlock: IndentBlocks.getPropsToSubparseToEolAndBlock
      rule: :explicitObjectBlock

    explicitObjectBlock:
      ""
        end*
        singleOrMultilineExplicitObject
        end*

    singleOrMultilineExplicitObject:
      :multilineExplicitObject
      :oneLineExplicitObject

  @rule

    implicitObject:
      "props:propertyList"

    oneLineExplicitObject:
      "props:explicitPropertyList"

    explicitObject:
      "'{}' _? props:explicitPropertyList"
      "'{}' _? props:objectLiteralBlock"
      "'{}'"

    bracketedObject: "openCurly_ props:explicitPropertyList _closeCurly"

    multilineImplicitObject:
      ""
        !implicitObjectWithTwoOrMorePropsOnOneLine
        valuePropWithComplexExpression
        multilineImplicitObjectExtension+


    multilineExplicitObject:
      ""
        explicitObjectLine
        multilineExplicitObjectExtension+

    {}
      getStn: ~>
        children = array m in @getMatchStns()
          if m instanceof ObjectStn.class
            m.children
          else
            m

        ObjectStn children

  @rule
    explicitObjectLine:
      :oneLineExplicitObject

      ""
        !implicitObjectWithTwoOrMorePropsOnOneLine
        explicitValuePropWithComplexExpression

    multilineImplicitObjectExtension:
      "end+ !implicitObjectWithTwoOrMorePropsOnOneLine valuePropWithComplexExpression"

    multilineExplicitObjectExtension:
      "end+ explicitObjectLine"

    implicitObjectWithTwoOrMorePropsOnOneLine:
      "literalProp _ propertyList"
      "valueProp _comma_optionalNewLine propertyList"

    explicitPropertyList:
      "valueProp optionalComma explicitPropertyList"
      "structurableProp _comma_optionalNewLine? explicitPropertyList"
      "explicitValuePropWithComplexExpression"

    propertyList:
      "valueProp optionalComma propertyList"
      "valuePropWithComplexExpression"

    implicitObjectStart: "propName _colon_"

  @rule
    literalProp:  "propName _colon_ propValue:literal"
    valueProp:    "propName _colon_ propValue:singleValueOrImplicitArrayWithoutImplicitObjects"

    valuePropWithComplexExpression:
      "propName _colon_ propValue:singleValueOrImplicitArrayWithoutImplicitObjects"

    {}
      name: "literalObjectProperty"
      stnFactory: :ObjectPropValueStn

  @rule
    explicitValuePropWithComplexExpression:
      :valuePropWithComplexExpression
      :structurableProp

    structurableProp:
      :expression
      stnFactory: :ObjectPropValueStn

  @rule
    propName: "computedPropName"
    computedPropName:
      pattern: "openBracket_ expression _closeBracket"
      stnFactory: "ObjectLiteralAccessorStn"

  @rule
    stringLiteralPropNameTail: [
      "_ /:/ !unquotedString"
      "/:/"
    ]

  @rule
    thisPropName: "/@/ unquotedString?"
    {}
      stnFactory: :ThisStn
      stnProps: ~> identifier: @unquotedString.toString()

  @rule
    propName:
      "!/then\\s/ str:thisPropName &_colon_"
    {}
      stnFactory: "ObjectPropNameStn"
      stnProps: ~>
        isThisProp: true

  @rule
    propName:
      "!/then\\s/ str:identifier &_colon_"
      "!/then\\s/ str:unquotedString &/:/"
      "quotedString:stringLiteral &stringLiteralPropNameTail"

    {}
      stnFactory: "ObjectPropNameStn"
      stnProps: ~>
        value: @str?.toString()
        isThisProp: false
